package com.algorithm.backtracking;

import java.util.Arrays;

/**
 * https://leetcode-cn.com/problems/maximum-number-of-accepted-invitations/
 * 1820. 最多邀请的个数
 * 某一个班级有 m 个男孩和 n 个女孩，即将举行一个派对。
 *
 * 给定一个 m x n 的整数矩阵 grid ，其中 grid[i][j] 等于 0 或 1 。 若 grid[i][j] == 1 ，则表示第 i 个男孩可以邀请第 j 个女孩参加派对。 一个男孩最多可以邀请一个女孩，一个女孩最多可以接受一个男孩的一个邀请。
 *
 * 返回可能的最多邀请的个数。
 *
 * 示例 1:
 *
 * 输入: grid = [[1,1,1],
 *                [1,0,1],
 *                [0,0,1]]
 * 输出: 3
 * 解释: 按下列方式邀请：
 * - 第 1 个男孩邀请第 2 个女孩。
 * - 第 2 个男孩邀请第 1 个女孩。
 * - 第 3 个男孩邀请第 3 个女孩。
 * 示例 2:
 *
 * 输入: grid = [[1,0,1,0],
 *                [1,0,0,0],
 *                [0,0,1,0],
 *                [1,1,1,0]]
 * 输出: 3
 * 解释: 按下列方式邀请：
 * - 第 1 个男孩邀请第 3 个女孩。
 * - 第 2 个男孩邀请第 1 个女孩。
 * - 第 3 个男孩未邀请任何人。
 * - 第 4 个男孩邀请第 2 个女孩。
 *
 *
 * 提示：
 *
 * grid.length == m
 * grid[i].length == n
 * 1 <= m, n <= 200
 * grid[i][j] 是 0 或 1 之一。
 *
 *
 */
public class MaximumInvitations {
    public static void main(String[] args) {
        MaximumInvitations i = new MaximumInvitations();
        int[][] grid = new int[][] {{1,0,1,0},{1,0,0,0},{0,0,1,0},{1,1,1,0}};
        System.out.println(i.maximumInvitations(grid));
        
        int[][] grid1 = new int[][] {{0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},{0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0},{1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,0},{0,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0},{0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0},{1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,0},{0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0},{0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1},{0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,0,1},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,1,0},{0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,1,1,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0},{1,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0},{0,0,1,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,0,0},{0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,1,0},{0,0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0},{0,0,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,1,1},{0,0,1,0,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0},{0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0}};
        System.out.println(i.maximumInvitations(grid1));
    }
    public int maximumInvitations(int[][] grid) {
        int m = grid.length, n = grid[0].length, ans = 0;
        boolean[] visited = new boolean[n];
        int[] matches = new int[n];
	    Arrays.fill(matches, -1);
        for (int i = 0; i < m; i++) {
            Arrays.fill(visited, false);
            if (dfsHelper(grid, i, n, visited, matches)) {
                ans++;
            }
        }
        return ans;
    }
    
    boolean dfsHelper(int[][] grid, int row, int n, boolean[] visited, int[] matches) {
        for (int i = 0; i < n; i++) {
            if (grid[row][i] == 0 || visited[i]) {
                continue;
            }
            visited[i] = true;
            if (matches[i] == -1 || dfsHelper(grid, matches[i], n, visited, matches)) {
                matches[i] = row;
                return true;
            }
        }
        return false;
    }
}
